{"code":"import React from \"react\";\r\nimport { useGraph } from \"./Context\";\r\nimport { verticalLineFullHeight } from \"./projections\";\r\nconst defaultLineStyle = {\r\n    fill: \"none\",\r\n    stroke: \"black\",\r\n    strokeWidth: 1,\r\n};\r\nconst defaultTerminalStyle = {\r\n    fill: \"black\",\r\n    r: 2,\r\n    stroke: \"white\",\r\n    strokeWidth: 1,\r\n};\r\nexport const ScrubberControlVertical = ({ lineStyle = {}, terminalStyle = {}, }) => {\r\n    lineStyle = { ...defaultLineStyle, ...lineStyle };\r\n    terminalStyle = { ...defaultTerminalStyle, ...terminalStyle };\r\n    const graph = useGraph();\r\n    const { x1, x2, y1, y2 } = verticalLineFullHeight(graph, 0);\r\n    return (React.createElement(\"g\", { \"data-componentid\": \"scrubbercontrol\" },\r\n        React.createElement(\"circle\", { cx: x1, cy: y1, style: terminalStyle }),\r\n        React.createElement(\"line\", { x1: x1, x2: x2, y1: y1, y2: y2, style: lineStyle }),\r\n        React.createElement(\"circle\", { cx: x1, cy: y2, style: terminalStyle })));\r\n};\r\nexport const ScrubberXAxis = ({ children, setCurrentDataPoint, currentDataPoint, thumbColour = \"black\", }) => {\r\n    const graph = useGraph();\r\n    const numPoints = graph.yAxisValues.length;\r\n    const scrubWindowRef = React.useRef(null);\r\n    const [slidingWindowWidth, setSlidingWindowWidth] = React.useState(0);\r\n    const [slideAmount, setSlideAmount] = React.useState(0);\r\n    React.useLayoutEffect(() => {\r\n        const scrubWindowWidth = scrubWindowRef.current\r\n            .clientWidth;\r\n        if (graph.xAxisSize <= scrubWindowWidth) {\r\n            setSlidingWindowWidth(graph.xAxisSize);\r\n        }\r\n        else {\r\n            setSlidingWindowWidth(scrubWindowRef.current.clientWidth);\r\n        }\r\n    }, [scrubWindowRef.current, numPoints]);\r\n    const scrubHandler = (e) => {\r\n        const overflow = slidingWindowWidth - graph.xAxisSize;\r\n        const percent = +e.target.value / numPoints;\r\n        setCurrentDataPoint(+e.target.value);\r\n        setSlideAmount(percent * overflow);\r\n    };\r\n    return (React.createElement(\"figure\", { ref: scrubWindowRef, style: {\r\n            position: \"relative\",\r\n            overflowX: \"hidden\",\r\n            overflowY: \"visible\",\r\n            height: graph.yAxisSize,\r\n            maxWidth: graph.xAxisSize,\r\n        } },\r\n        React.createElement(\"div\", { style: {\r\n                transform: `translateX(${slideAmount}px)`,\r\n                width: graph.xAxisSize,\r\n                height: graph.yAxisSize,\r\n            } }, children),\r\n        React.createElement(\"input\", { max: numPoints - 1, min: 0, onChange: scrubHandler, step: 1, css: {\r\n                outline: \"none\",\r\n                height: \"100%\",\r\n                width: \"100%\",\r\n                top: 0,\r\n                display: \"block\",\r\n                position: \"absolute\",\r\n                zIndex: 1,\r\n                backgroundColor: \"transparent\",\r\n                \"&::-webkit-slider-thumb\": {\r\n                    height: graph.yAxisSize,\r\n                    width: 4,\r\n                    backgroundColor: thumbColour,\r\n                    border: 0,\r\n                    borderRadius: 0,\r\n                    display: \"block\",\r\n                    position: \"relative\",\r\n                },\r\n                \"&::-moz-range-thumb\": {\r\n                    height: graph.yAxisSize,\r\n                    width: 4,\r\n                    backgroundColor: thumbColour,\r\n                    border: 0,\r\n                    borderRadius: 0,\r\n                    display: \"block\",\r\n                    position: \"relative\",\r\n                },\r\n                \"&::-ms-thumb\": {\r\n                    height: graph.yAxisSize,\r\n                    width: 4,\r\n                    backgroundColor: thumbColour,\r\n                    border: 0,\r\n                    borderRadius: 0,\r\n                    display: \"block\",\r\n                    position: \"relative\",\r\n                },\r\n            }, type: \"range\", value: currentDataPoint })));\r\n};\r\n//# sourceMappingURL=Scrubber.js.map","references":["/Users/daniel.couper/Work/shared-frontend-libs/.yarn/cache/@types-react-npm-17.0.0-d4f5adb6f0-dcef2034b8.zip/node_modules/@types/react/index.d.ts","/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/src/Graph/Context.tsx","/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/src/Graph/projections.ts"],"map":"{\"version\":3,\"file\":\"Scrubber.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/Graph/Scrubber.tsx\"],\"names\":[],\"mappings\":\"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\"}","dtsmap":{"name":"/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/node_modules/.cache/rollup-plugin-typescript2/placeholder/Graph/Scrubber.d.ts.map","writeByteOrderMark":false,"text":"{\"version\":3,\"file\":\"Scrubber.d.ts\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/Graph/Scrubber.tsx\"],\"names\":[],\"mappings\":\"AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAK1B,MAAM,WAAW,oBAAoB;IACpC,qBAAqB,EAAE,MAAM,CAAC;IAC9B,wBAAwB,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,CAAC;IAC9C,SAAS,CAAC,EAAE,KAAK,CAAC,aAAa,CAAC;IAChC,aAAa,CAAC,EAAE,KAAK,CAAC,aAAa,CAAC;CACpC;AAeD,eAAO,MAAM,uBAAuB,kCAGjC,oBAAoB,KAAG,WAczB,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCG;AACH,MAAM,WAAW,aAAa;IAC7B,QAAQ,EAAE,KAAK,CAAC,SAAS,CAAC;IAC1B,gBAAgB,EAAE,MAAM,CAAC;IACzB,mBAAmB,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,CAAC;IACzC,WAAW,CAAC,EAAE,MAAM,CAAC;CACrB;AAED,eAAO,MAAM,aAAa,sEAKvB,aAAa,KAAG,WAgGlB,CAAC\"}"},"dts":{"name":"/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/node_modules/.cache/rollup-plugin-typescript2/placeholder/Graph/Scrubber.d.ts","writeByteOrderMark":false,"text":"import React from \"react\";\r\nexport interface ScrubberControlProps {\r\n    currentDataPointIndex: number;\r\n    setCurrentDataPointIndex: (n: number) => void;\r\n    lineStyle?: React.CSSProperties;\r\n    terminalStyle?: React.CSSProperties;\r\n}\r\nexport declare const ScrubberControlVertical: ({ lineStyle, terminalStyle, }: ScrubberControlProps) => JSX.Element;\r\n/**\r\n * This needs some explanation. For a graph to have a scrubber control, that implies the\r\n * scrubber control is going to relate to {something} external to the graph. So passed into\r\n * this needs to be a callback function that triggers on each step of the scrubber: that\r\n * listener is defined elsewhere and is completely unknown to the graph.\r\n *\r\n * The scrubber, is built on an HTML \"range\" type input, styled as a vertical line.\r\n * This provides immediate accessibility benefits. On focus, for example, dragging\r\n * and keyboard controls work perfectly.\r\n *\r\n * The scrubber consists of:\r\n *\r\n * 1. An outer wrapper, with the width/height (depending on orientation) set to\r\n *    _either_ full width/height of the container or, if the graph width/height is smaller\r\n *    than that, the width/height of the graph. This width/height is calculated by using a ref\r\n *  and the\r\n *    `clientWidth` DOM method. This outer wrapper has overflow hidden.\r\n * 2. An inner wrapper that contains, as a child, the graph SVG/canvas/whatever. This will be\r\n *    offset to the left or top (`slideAmount`) IF the graph is wider than the `slidingWindowWidth`\r\n *    state by using:\r\n *        rangePercent * overflow\r\n *    which is calculated:\r\n *        (selectedSpeedGraphLocation / numPoints) * (slidingWindowWidth - graph.xAxisSize)\r\n *    A CSS transform function (translateX) is used to apply this:\r\n *        transform: `translateX(0 - ${slideAmount}px)`\r\n *    So, for example, say the sliding window is 200px wide, and the graph is 300px, and\r\n *    there are 300 points (_ie_ the scaling is 1).\r\n *      - When the range slider is at 0, the offset is also 0: `(0 / 300) * (200 - (300 * 1))`\r\n *      - When the range slider is at 300, the offset is -100: `(300 / 300) * (200 - (300 * 1))`\r\n *      - When the range slider is at 150, the offset is -50: `(150 / 300) * (200 - (300 * 1))`\r\n * 3. The Scrubber is a range slider absolutely positioned over the top of the graph\r\n *    styled to look like a vertical bar.It's `min` is 0, its `max` is the total number of\r\n *    points, and its current value is the current point (`currentDataPoint`).\r\n *    When the value is changed, the handler updates the  `selectedSpeedgraphLocation` value and the\r\n *    `slideAmount` recalculated.\r\n */\r\nexport interface ScrubberProps {\r\n    children: React.ReactNode;\r\n    currentDataPoint: number;\r\n    setCurrentDataPoint: (n: number) => void;\r\n    thumbColour?: string;\r\n}\r\nexport declare const ScrubberXAxis: ({ children, setCurrentDataPoint, currentDataPoint, thumbColour, }: ScrubberProps) => JSX.Element;\r\n//# sourceMappingURL=Scrubber.d.ts.map"}}
