{"code":"import React from \"react\";\r\nimport { useGraph } from \"./Context\";\r\nimport { verticalLineFullHeight } from \"./projections\";\r\nconst defaultLineStyle = {\r\n    fill: \"none\",\r\n    stroke: \"black\",\r\n    strokeWidth: 1,\r\n};\r\nconst defaultTerminalStyle = {\r\n    fill: \"black\",\r\n    r: 2,\r\n    stroke: \"white\",\r\n    strokeWidth: 1,\r\n};\r\nexport const ScrubberControlVertical = ({ lineStyle = {}, terminalStyle = {}, }) => {\r\n    lineStyle = { ...defaultLineStyle, ...lineStyle };\r\n    terminalStyle = { ...defaultTerminalStyle, ...terminalStyle };\r\n    const graph = useGraph();\r\n    const { x1, x2, y1, y2 } = verticalLineFullHeight(graph, 0);\r\n    return (React.createElement(\"g\", { \"data-componentid\": \"scrubbercontrol\" },\r\n        React.createElement(\"circle\", { cx: x1, cy: y1, style: terminalStyle }),\r\n        React.createElement(\"line\", { x1: x1, x2: x2, y1: y1, y2: y2, style: lineStyle }),\r\n        React.createElement(\"circle\", { cx: x1, cy: y2, style: terminalStyle })));\r\n};\r\n/**\r\n * This needs some explanation. For a graph to have a scrubber control, that implies the\r\n * scrubber control is going to relate to {something} external to the graph. So passed into\r\n * this needs to be a callback function that triggers on each step of the scrubber: that\r\n * listener is defined elsewhere and is completely unknown to the graph.\r\n *\r\n * The scrubber, is built on an HTML \"range\" type input, styled as a vertical line.\r\n * This provides immediate accessibility benefits. On focus, for example, dragging\r\n * and keyboard controls work perfectly.\r\n *\r\n * The scrubber consists of:\r\n *\r\n * 1. An outer wrapper, with the width/height (depending on orientation) set to\r\n *    _either_ full width/height of the container or, if the graph width/height is smaller\r\n *    than that, the width/height of the graph. This width/height is calculated by using a ref\r\n *  and the\r\n *    `clientWidth` DOM method. This outer wrapper has overflow hidden.\r\n * 2. An inner wrapper that contains, as a child, the graph SVG/canvas/whatever. This will be\r\n *    offset to the left or top (`slideAmount`) IF the graph is wider than the `slidingWindowWidth`\r\n *    state by using:\r\n *        rangePercent * overflow\r\n *    which is calculated:\r\n *        (selectedSpeedGraphLocation / numPoints) * (slidingWindowWidth - graph.xAxisSize)\r\n *    A CSS transform function (translateX) is used to apply this:\r\n *        transform: `translateX(0 - ${slideAmount}px)`\r\n *    So, for example, say the sliding window is 200px wide, and the graph is 300px, and\r\n *    there are 300 points (_ie_ the scaling is 1).\r\n *      - When the range slider is at 0, the offset is also 0: `(0 / 300) * (200 - (300 * 1))`\r\n *      - When the range slider is at 300, the offset is -100: `(300 / 300) * (200 - (300 * 1))`\r\n *      - When the range slider is at 150, the offset is -50: `(150 / 300) * (200 - (300 * 1))`\r\n * 3. The Scrubber is a range slider absolutely positioned over the top of the graph\r\n *    styled to look like a vertical bar.It's `min` is 0, its `max` is the total number of\r\n *    points, and its current value is the current point (`currentDataPoint`).\r\n *    When the value is changed, the handler updates the  `selectedSpeedgraphLocation` value and the\r\n *    `slideAmount` recalculated.\r\n */\r\n// export interface ScrubberProps {\r\n// \tchildren: React.ReactNode;\r\n// \tcurrentDataPoint: number;\r\n// \tsetCurrentDataPoint: (n: number) => void;\r\n// \tthumbColour?: string;\r\n// }\r\n// export const ScrubberXAxis = ({\r\n// \tchildren,\r\n// \tsetCurrentDataPoint,\r\n// \tcurrentDataPoint,\r\n// \tthumbColour = \"black\",\r\n// }: ScrubberProps): JSX.Element => {\r\n// \tconst graph = useGraph();\r\n// \tconst numPoints = graph.yAxisValues.length;\r\n// \tconst scrubWindowRef = React.useRef<HTMLDivElement>(null);\r\n// \tconst [slidingWindowWidth, setSlidingWindowWidth] = React.useState(0);\r\n// \tconst [slideAmount, setSlideAmount] = React.useState(0);\r\n// \tReact.useLayoutEffect(() => {\r\n// \t\tconst scrubWindowWidth = (scrubWindowRef.current as HTMLDivElement)\r\n// \t\t\t.clientWidth;\r\n// \t\tif (graph.xAxisSize <= scrubWindowWidth) {\r\n// \t\t\tsetSlidingWindowWidth(graph.xAxisSize);\r\n// \t\t} else {\r\n// \t\t\tsetSlidingWindowWidth(\r\n// \t\t\t\t(scrubWindowRef.current as HTMLDivElement).clientWidth\r\n// \t\t\t);\r\n// \t\t}\r\n// \t}, [scrubWindowRef.current, numPoints]);\r\n// \tconst scrubHandler = (e: React.ChangeEvent) => {\r\n// \t\tconst overflow = slidingWindowWidth - graph.xAxisSize;\r\n// \t\tconst percent = +(e.target as HTMLInputElement).value / numPoints;\r\n// \t\tsetCurrentDataPoint(+(e.target as HTMLInputElement).value);\r\n// \t\tsetSlideAmount(percent * overflow);\r\n// \t};\r\n// \treturn (\r\n// \t\t<figure\r\n// \t\t\tref={scrubWindowRef}\r\n// \t\t\tstyle={{\r\n// \t\t\t\tposition: \"relative\",\r\n// \t\t\t\toverflowX: \"hidden\",\r\n// \t\t\t\toverflowY: \"visible\",\r\n// \t\t\t\theight: graph.yAxisSize,\r\n// \t\t\t\tmaxWidth: graph.xAxisSize,\r\n// \t\t\t}}\r\n// \t\t>\r\n// \t\t\t<div\r\n// \t\t\t\tstyle={{\r\n// \t\t\t\t\ttransform: `translateX(${slideAmount}px)`,\r\n// \t\t\t\t\twidth: graph.xAxisSize,\r\n// \t\t\t\t\theight: graph.yAxisSize,\r\n// \t\t\t\t}}\r\n// \t\t\t>\r\n// \t\t\t\t{children}\r\n// \t\t\t</div>\r\n// \t\t\t<input\r\n// \t\t\t\tmax={numPoints - 1}\r\n// \t\t\t\tmin={0}\r\n// \t\t\t\tonChange={scrubHandler}\r\n// \t\t\t\tstep={1}\r\n// \t\t\t\tcss={{\r\n// \t\t\t\t\toutline: \"none\",\r\n// \t\t\t\t\theight: \"100%\",\r\n// \t\t\t\t\twidth: \"100%\",\r\n// \t\t\t\t\ttop: 0,\r\n// \t\t\t\t\tdisplay: \"block\",\r\n// \t\t\t\t\tposition: \"absolute\",\r\n// \t\t\t\t\tzIndex: 1,\r\n// \t\t\t\t\tbackgroundColor: \"transparent\",\r\n// \t\t\t\t\t\"&::-webkit-slider-thumb\": {\r\n// \t\t\t\t\t\theight: graph.yAxisSize,\r\n// \t\t\t\t\t\twidth: 4,\r\n// \t\t\t\t\t\tbackgroundColor: thumbColour,\r\n// \t\t\t\t\t\tborder: 0,\r\n// \t\t\t\t\t\tborderRadius: 0,\r\n// \t\t\t\t\t\tdisplay: \"block\",\r\n// \t\t\t\t\t\tposition: \"relative\",\r\n// \t\t\t\t\t},\r\n// \t\t\t\t\t\"&::-moz-range-thumb\": {\r\n// \t\t\t\t\t\theight: graph.yAxisSize,\r\n// \t\t\t\t\t\twidth: 4,\r\n// \t\t\t\t\t\tbackgroundColor: thumbColour,\r\n// \t\t\t\t\t\tborder: 0,\r\n// \t\t\t\t\t\tborderRadius: 0,\r\n// \t\t\t\t\t\tdisplay: \"block\",\r\n// \t\t\t\t\t\tposition: \"relative\",\r\n// \t\t\t\t\t},\r\n// \t\t\t\t\t\"&::-ms-thumb\": {\r\n// \t\t\t\t\t\theight: graph.yAxisSize,\r\n// \t\t\t\t\t\twidth: 4,\r\n// \t\t\t\t\t\tbackgroundColor: thumbColour,\r\n// \t\t\t\t\t\tborder: 0,\r\n// \t\t\t\t\t\tborderRadius: 0,\r\n// \t\t\t\t\t\tdisplay: \"block\",\r\n// \t\t\t\t\t\tposition: \"relative\",\r\n// \t\t\t\t\t},\r\n// \t\t\t\t}}\r\n// \t\t\t\ttype=\"range\"\r\n// \t\t\t\tvalue={currentDataPoint}\r\n// \t\t\t/>\r\n// \t\t</figure>\r\n// \t);\r\n// };\r\n//# sourceMappingURL=Scrubber.js.map","references":["/Users/daniel.couper/Work/shared-frontend-libs/.yarn/cache/@types-react-npm-17.0.0-d4f5adb6f0-dcef2034b8.zip/node_modules/@types/react/index.d.ts","/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/src/Graph/Context.tsx","/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/src/Graph/projections.ts"],"map":"{\"version\":3,\"file\":\"Scrubber.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/Graph/Scrubber.tsx\"],\"names\":[],\"mappings\":\"AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AACrC,OAAO,EAAE,sBAAsB,EAAE,MAAM,eAAe,CAAC;AASvD,MAAM,gBAAgB,GAAG;IACxB,IAAI,EAAE,MAAM;IACZ,MAAM,EAAE,OAAO;IACf,WAAW,EAAE,CAAC;CACd,CAAC;AAEF,MAAM,oBAAoB,GAAG;IAC5B,IAAI,EAAE,OAAO;IACb,CAAC,EAAE,CAAC;IACJ,MAAM,EAAE,OAAO;IACf,WAAW,EAAE,CAAC;CACd,CAAC;AAEF,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,EACvC,SAAS,GAAG,EAAE,EACd,aAAa,GAAG,EAAE,GACI,EAAe,EAAE;IACvC,SAAS,GAAG,EAAE,GAAG,gBAAgB,EAAE,GAAG,SAAS,EAAE,CAAC;IAClD,aAAa,GAAG,EAAE,GAAG,oBAAoB,EAAE,GAAG,aAAa,EAAE,CAAC;IAE9D,MAAM,KAAK,GAAG,QAAQ,EAAE,CAAC;IACzB,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,sBAAsB,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAE5D,OAAO,CACN,+CAAoB,iBAAiB;QACpC,gCAAQ,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,aAAa,GAAI;QAChD,8BAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,SAAS,GAAI;QAC1D,gCAAQ,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,aAAa,GAAI,CAC7C,CACJ,CAAC;AACH,CAAC,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCG;AACH,mCAAmC;AACnC,8BAA8B;AAC9B,6BAA6B;AAC7B,6CAA6C;AAC7C,yBAAyB;AACzB,IAAI;AAEJ,kCAAkC;AAClC,aAAa;AACb,wBAAwB;AACxB,qBAAqB;AACrB,0BAA0B;AAC1B,sCAAsC;AACtC,6BAA6B;AAC7B,+CAA+C;AAE/C,8DAA8D;AAC9D,0EAA0E;AAC1E,4DAA4D;AAE5D,iCAAiC;AACjC,wEAAwE;AACxE,mBAAmB;AAEnB,+CAA+C;AAC/C,6CAA6C;AAC7C,aAAa;AACb,4BAA4B;AAC5B,6DAA6D;AAC7D,QAAQ;AACR,MAAM;AACN,4CAA4C;AAE5C,oDAAoD;AACpD,2DAA2D;AAC3D,uEAAuE;AAEvE,gEAAgE;AAChE,wCAAwC;AACxC,MAAM;AAEN,YAAY;AACZ,YAAY;AACZ,0BAA0B;AAC1B,cAAc;AACd,4BAA4B;AAC5B,2BAA2B;AAC3B,4BAA4B;AAC5B,+BAA+B;AAC/B,iCAAiC;AACjC,QAAQ;AACR,MAAM;AACN,UAAU;AACV,eAAe;AACf,kDAAkD;AAClD,+BAA+B;AAC/B,gCAAgC;AAChC,SAAS;AACT,OAAO;AACP,iBAAiB;AACjB,YAAY;AACZ,YAAY;AACZ,0BAA0B;AAC1B,cAAc;AACd,8BAA8B;AAC9B,eAAe;AACf,aAAa;AACb,wBAAwB;AACxB,uBAAuB;AACvB,sBAAsB;AACtB,eAAe;AACf,yBAAyB;AACzB,6BAA6B;AAC7B,kBAAkB;AAClB,uCAAuC;AACvC,oCAAoC;AACpC,iCAAiC;AACjC,kBAAkB;AAClB,sCAAsC;AACtC,mBAAmB;AACnB,yBAAyB;AACzB,0BAA0B;AAC1B,8BAA8B;AAC9B,UAAU;AACV,gCAAgC;AAChC,iCAAiC;AACjC,kBAAkB;AAClB,sCAAsC;AACtC,mBAAmB;AACnB,yBAAyB;AACzB,0BAA0B;AAC1B,8BAA8B;AAC9B,UAAU;AACV,yBAAyB;AACzB,iCAAiC;AACjC,kBAAkB;AAClB,sCAAsC;AACtC,mBAAmB;AACnB,yBAAyB;AACzB,0BAA0B;AAC1B,8BAA8B;AAC9B,UAAU;AACV,SAAS;AACT,mBAAmB;AACnB,+BAA+B;AAC/B,QAAQ;AACR,cAAc;AACd,MAAM;AACN,KAAK\"}","dtsmap":{"name":"/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/node_modules/.cache/rollup-plugin-typescript2/placeholder/Graph/Scrubber.d.ts.map","writeByteOrderMark":false,"text":"{\"version\":3,\"file\":\"Scrubber.d.ts\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/Graph/Scrubber.tsx\"],\"names\":[],\"mappings\":\"AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAK1B,MAAM,WAAW,oBAAoB;IACpC,qBAAqB,EAAE,MAAM,CAAC;IAC9B,wBAAwB,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,CAAC;IAC9C,SAAS,CAAC,EAAE,KAAK,CAAC,aAAa,CAAC;IAChC,aAAa,CAAC,EAAE,KAAK,CAAC,aAAa,CAAC;CACpC;AAeD,eAAO,MAAM,uBAAuB,kCAGjC,oBAAoB,KAAG,WAczB,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCG\"}"},"dts":{"name":"/Users/daniel.couper/Work/shared-frontend-libs/packages/dataviz/node_modules/.cache/rollup-plugin-typescript2/placeholder/Graph/Scrubber.d.ts","writeByteOrderMark":false,"text":"import React from \"react\";\r\nexport interface ScrubberControlProps {\r\n    currentDataPointIndex: number;\r\n    setCurrentDataPointIndex: (n: number) => void;\r\n    lineStyle?: React.CSSProperties;\r\n    terminalStyle?: React.CSSProperties;\r\n}\r\nexport declare const ScrubberControlVertical: ({ lineStyle, terminalStyle, }: ScrubberControlProps) => JSX.Element;\r\n/**\r\n * This needs some explanation. For a graph to have a scrubber control, that implies the\r\n * scrubber control is going to relate to {something} external to the graph. So passed into\r\n * this needs to be a callback function that triggers on each step of the scrubber: that\r\n * listener is defined elsewhere and is completely unknown to the graph.\r\n *\r\n * The scrubber, is built on an HTML \"range\" type input, styled as a vertical line.\r\n * This provides immediate accessibility benefits. On focus, for example, dragging\r\n * and keyboard controls work perfectly.\r\n *\r\n * The scrubber consists of:\r\n *\r\n * 1. An outer wrapper, with the width/height (depending on orientation) set to\r\n *    _either_ full width/height of the container or, if the graph width/height is smaller\r\n *    than that, the width/height of the graph. This width/height is calculated by using a ref\r\n *  and the\r\n *    `clientWidth` DOM method. This outer wrapper has overflow hidden.\r\n * 2. An inner wrapper that contains, as a child, the graph SVG/canvas/whatever. This will be\r\n *    offset to the left or top (`slideAmount`) IF the graph is wider than the `slidingWindowWidth`\r\n *    state by using:\r\n *        rangePercent * overflow\r\n *    which is calculated:\r\n *        (selectedSpeedGraphLocation / numPoints) * (slidingWindowWidth - graph.xAxisSize)\r\n *    A CSS transform function (translateX) is used to apply this:\r\n *        transform: `translateX(0 - ${slideAmount}px)`\r\n *    So, for example, say the sliding window is 200px wide, and the graph is 300px, and\r\n *    there are 300 points (_ie_ the scaling is 1).\r\n *      - When the range slider is at 0, the offset is also 0: `(0 / 300) * (200 - (300 * 1))`\r\n *      - When the range slider is at 300, the offset is -100: `(300 / 300) * (200 - (300 * 1))`\r\n *      - When the range slider is at 150, the offset is -50: `(150 / 300) * (200 - (300 * 1))`\r\n * 3. The Scrubber is a range slider absolutely positioned over the top of the graph\r\n *    styled to look like a vertical bar.It's `min` is 0, its `max` is the total number of\r\n *    points, and its current value is the current point (`currentDataPoint`).\r\n *    When the value is changed, the handler updates the  `selectedSpeedgraphLocation` value and the\r\n *    `slideAmount` recalculated.\r\n */\r\n//# sourceMappingURL=Scrubber.d.ts.map"}}
